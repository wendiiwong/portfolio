I"
<hr />
<h1 id="c-compiler-build-pipeline">C++ Compiler Build Pipeline</h1>
<p>Basically, the compiler takes each C++ source file in the working directory and compiles them into object files. These object files produced are then linked together with libraries or symbols to produce an executable files, which is our program.</p>

<p><img src="/wendi/images/20200220_how_compiler_works/01.jpg" alt="" />
<em>The compiler compiles Main.cpp to Main.obj</em></p>

<p><img src="/wendi/images/20200220_how_compiler_works/02.jpg" alt="" />
<em>The compiler compiles Main.cpp to Main.obj</em></p>

<p><br /><br /></p>
<h4 id="the-compiler-works-in-three-main-stages-">The compiler works in three main stages :</h4>
<ul>
  <li><strong>Stage 1</strong> : Preprocessing</li>
  <li><strong>Stage 2</strong> : Compiling</li>
  <li><strong>Stage 3</strong> : Linking</li>
</ul>

<hr />
<h1 id="stage-1--preprocessing">Stage 1 : Preprocessing</h1>
<p>First, the compiler will run the <em><strong>preprocessor</strong></em> on all the source files (only source files, no header files). 
Each C++ source file will then be built into a <em><strong>translation unit</strong></em> which resulted as object file in the later stage.</p>

<p>Compiler will go through all our <em><strong>preprocessor directives</strong></em> and resolves them before compilation stage.</p>

<hr />
<h4 id="how-preprocessor-resolve-include">How preprocessor resolve #include</h4>
<p>The most commonly used preprocessor directive would be <em><code class="highlighter-rouge">#include</code></em>, and I believe it is crucial for every C++ developer to know how it works.</p>

<p>Let’s take a look at a simple <em><code class="highlighter-rouge">Math.cpp</code></em> that add 2 numbers,</p>

<p><strong>Math.h</strong></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span></code></pre></figure>

<p><strong>Math.cpp</strong></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include "Math.h"
</span>
<span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Note that <em><code class="highlighter-rouge">Math.cpp</code></em> has a preprocessor directive  <em><code class="highlighter-rouge">#include</code></em> that include <em><code class="highlighter-rouge">Math.h</code></em>. What the processor will do it open the contents in <em><code class="highlighter-rouge">Math.h</code></em>, read all the contents inside, and paste it into our <em><code class="highlighter-rouge">Math.cpp</code></em>.</p>

<p>To have a better understanding, we could request the compiler to give us the preprocessed source that look like this:</p>

<p><strong>Math.i (Preprocessed C/C++ source)</strong></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#line 1 "D:\\wendi_blog_code_exp\\HelloWorld\\HelloWorld\\Math.cpp"
#line 1 "D:\\wendi_blog_code_exp\\HelloWorld\\HelloWorld\\Math.h"
</span><span class="kt">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="cp">#line 2 "D:\\wendi_blog_code_exp\\HelloWorld\\HelloWorld\\Math.cpp"
</span>
<span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">num1</span> <span class="o">+</span> <span class="n">num2</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Noticed that “<em><code class="highlighter-rouge">int num2 = 2</code></em>” has been copied from <em><code class="highlighter-rouge">Math.h</code></em> to <em><code class="highlighter-rouge">Math.cpp</code></em>. That’s all, it’s pretty simple.</p>

<hr />

<p>Now, Let’s assume we have a <em><code class="highlighter-rouge">Main.cpp</code></em> that prints “Hello World” on screen:</p>

<p><strong>Main.cpp</strong></p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And if we look at the preprocessed C/C++ Source files produced :</p>

<p><img src="/wendi/images/20200220_how_compiler_works/03.PNG" alt="" /></p>

<p>Noticed that the file size of <em><code class="highlighter-rouge">Main.i(1.34MB)</code></em> is much more larger than <em><code class="highlighter-rouge">Math.i(269 bytes)</code></em> even though the line of codes are similar. That’s because we include a huge and massive <em><code class="highlighter-rouge">&lt;iostream&gt;</code></em> in <em><code class="highlighter-rouge">Main.cpp</code></em>.</p>

<hr />
<h1 id="stage-2--compiling">Stage 2 : Compiling</h1>

<p>After preprocessor done it’s job, the compiler will then take our C++ source code and compiles them into obj files. This obj file / object file is in binary, and contains computer understandable machine code.</p>

<p>We can view these code in assembly file. compiler is able to produce an assembly listing file as output.</p>

<p>From the assembly file, we can see that our add operation has been converted into assembly instructions.
first instruction move num1 to registry eax, and second instruction add num2 with num1 and store it in eax.</p>

<figure class="highlight"><pre><code class="language-assembly" data-lang="assembly">; Line 5
	mov	eax, DWORD PTR _num1$[ebp]
	add	eax, DWORD PTR ?num2@@3HA		; num2
; Line 6</code></pre></figure>

<p>— Working in Progress —</p>
:ET